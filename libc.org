* Error Reporting

#+BEGIN_SRC C :includes <errno.h>
printf ("The initial value of errno is %d", errno);
#+END_SRC

#+RESULTS:
: The initial value of errno is 0

#+BEGIN_SRC C :includes <errno.h> <string.h> :results output
int errs[] = { EPERM, ENOENT, ESRCH, EINTR, EIO, ENXIO, E2BIG, ENOEXEC, EBADF, ENOMEM };
int size = sizeof errs / sizeof (int);

for (int i = 0; i < size; i++)
  puts (strerror (errs[i]));
#+END_SRC

#+RESULTS:
#+BEGIN_EXAMPLE
Operation not permitted
No such file or directory
No such process
Interrupted system call
Input/output error
Device not configured
Argument list too long
Exec format error
Bad file descriptor
Cannot allocate memory
#+END_EXAMPLE

#+BEGIN_SRC C :includes <stdio.h> <errno.h> <string.h>
char *filename = "nonexist.txt";
FILE *file = fopen (filename, "r");
if (file == NULL)
  {
    fprintf (stdout,      /* Should be stderr, but org-babel doesn't allow it */
             "%s: Couldn't open file %s; %s\n",
             "libc.org",
             filename,
             strerror (errno));
  }
#+END_SRC

#+RESULTS:
: libc.org: Couldn't open file nonexist.txt; No such file or directory

* Memory

#+BEGIN_SRC C :cmdline (number-to-string (1+ (random 10)))
#include <stdlib.h>
#include <assert.h>
#include <time.h>

int
main (int argc, char *argv[])
{
  assert (argc > 1);
  int size = atoi (argv[1]);
  assert (size > 0);
  int *ptr = malloc (size * sizeof (int));
  if (NULL == ptr)
    {
      perror ("malloc");
      exit (EXIT_FAILURE);
    }
  srandom (time (0));
  for (int i = 0; i < size; i++)
    ptr[i] = random () % 10;
  for (int i = 0; i < size; i++)
    printf ("%d\n", ptr[i]);
  free (ptr);
  return 0;
}
#+END_SRC

#+RESULTS:
| 2 |
| 1 |
| 0 |
| 2 |
| 5 |
| 4 |

C99 variable-length arrays:

#+BEGIN_SRC C :cmdline (number-to-string (1+ (random 10)))
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

int
main (int argc, char *argv[])
{
  assert (argv[1] != NULL);
  int size = atoi (argv[1]);
  assert (size > 0);
  int ary[size];
  for (int i = 0; i < size; i++)
    ary[i] = random () % 10;
  for (int i = 0; i < size; i++)
    printf ("%d\n", ary[i]);
  return 0;
}
#+END_SRC

#+RESULTS:
| 3 |
| 6 |
| 7 |
| 5 |
| 3 |
| 5 |

* Character Handling

Classification of Characters:

- lower/upper case
- letter
- digit
- punctuation
- whitespaces
- blank
- graph
- print
- cntrl
- ascii

#+BEGIN_SRC C :includes <ctype.h> <assert.h> :results silent
assert (islower ('a'));
assert (isupper ('A'));
assert (isalpha ('a'));
assert (isdigit ('3'));
assert (isalnum ('a') && isalnum ('a'));
assert (isxdigit ('0') && isxdigit ('a'));
assert (ispunct (','));
char whitespaces[] = { ' ', '\f', '\n', '\r', '\t', '\v', 0 };
for (char *p = whitespaces; *p; p++)
  assert (isspace (*p));
assert (isblank (' ') && isblank ('\t'));
assert (isgraph ('a') && ! isgraph (' '));
assert (isprint ('a') && isprint (' '));
assert (iscntrl ('\t'));
#+END_SRC

Case Conversion:

#+BEGIN_SRC C :includes <ctype.h> <assert.h> :results silent
assert (tolower ('A') == 'a');
assert (toupper ('a') == 'A');
#+END_SRC

* String and Array Utilities
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <errno.h>
:END:

** C Strings

Concat string literals:

#+BEGIN_SRC C
puts ("Hello," " World!");
#+END_SRC

#+RESULTS:
: Hello, World!

** String Length

strlen returns the length of a string in bytes:

#+BEGIN_SRC C :includes <string.h>
printf ("%d\n", strlen ("hello, world"));
#+END_SRC

#+RESULTS:
: 12

sizeof returns the size of data type/variable in bytes:

#+BEGIN_SRC C :includes <string.h>
char string[32] = "hello, world";
printf ("sizeof = %d\n", sizeof (string));
printf ("strlen = %d\n", strlen (string));

char *ptr = string;
printf ("sizeof = %d\n", sizeof (ptr));
printf ("strlen = %d\n", strlen (ptr));
#+END_SRC

#+RESULTS:
: sizeof = 32
: strlen = 12
: sizeof = 8
: strlen = 12

implement strlen

#+BEGIN_SRC C
int
my_strlen (const char *S)
{
  int length = 0;
  while (*S++) length++;
  return length;
}

int
main ()
{
  printf ("%d = %d\n", strlen (""), my_strlen (""));
  printf ("%d = %d\n", strlen ("hi"), my_strlen ("hi"));
  char s[] = { 'h', 'i', '\0', '!' };
  printf ("%d = %d\n", strlen (s), my_strlen (s));
  return 0;
}
#+END_SRC

#+RESULTS:
: 0 = 0
: 2 = 2
: 2 = 2

** Copying Strings and Arrays
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <assert.h>
:END:

Copy array:

#+BEGIN_SRC C :cmdline "hello world"
int old[] = { 1, 2, 3, 4, 5 };

int length = sizeof old / sizeof (int);
int new[length];

assert (new == memcpy (new, old, sizeof old));

for (int i = 0; i < length; i++)
  printf ("%d\n", new[i]);
#+END_SRC

#+RESULTS:
: 1
: 2
: 3
: 4
: 5

Move array:

#+BEGIN_SRC C
int ary[5] = { 1, 2, 3 };
int len = sizeof ary / sizeof (int);
for (int i = 0; i < len; i++)
  printf ("%d%s", ary[i], i < len - 1 ? ", " : "\n");

memmove (ary + 2, ary, 3 * sizeof (int));

for (int i = 0; i < len; i++)
  printf ("%d%s", ary[i], i < len - 1 ? ", " : "\n");
#+END_SRC

#+RESULTS:
: 1, 2, 3, 0, 0
: 1, 2, 1, 2, 3

Copy string until character found:

#+BEGIN_SRC C
int from[] = { 1, 2, 3, 3, 3, 100 };
int len = sizeof from / sizeof (int);
for (int i = 0; i < len; i++)
  printf ("%d%s", from[i], i < len - 1 ? ", " : "\n");

int to[len];
/* assert (to + 2 == memccpy (to, from, 3, len * sizeof (int))); */
int *p = memccpy (to, from, 3, len * sizeof (int));
assert (p - to == 2);
printf ("%d ints copied.\n", (p - to) + 1);

for (int i = 0; i < len; i++)
  printf ("%d%s", to[i], i < len - 1 ? ", " : "\n");
#+END_SRC

#+RESULTS:
: 1, 2, 3, 3, 3, 100
: 3 ints copied.
: 1, 2, 3, 0, 1453651632, 32767

Fill character into a string:

#+BEGIN_SRC C
char s[10] = "hi";
memset (s + strlen (s), '!', sizeof s - strlen (s) - 1);
s[9] = 0;
puts (s);
#+END_SRC

#+RESULTS:
: hi!!!!!!!

Copy a string:

#+BEGIN_SRC C
char *s1 = "Hello World!";
char s2[strlen (s1) + 1];
puts (s1);
assert (s2 == strcpy (s2, s1));
puts (s2);
#+END_SRC

#+RESULTS:
: Hello World!
: Hello World!

Save a copy of a string:

#+BEGIN_SRC C
char *s = strdup ("Hello, World!");
assert (s);
puts (s);
free (s);
#+END_SRC

#+RESULTS:
: Hello, World!

Copy a string:

#+BEGIN_SRC C
char buffer[512];
stpcpy (stpcpy (buffer, "foo"), "bar");
puts (buffer);
#+END_SRC

#+RESULTS:
: foobar

** Concatenating Strings
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <assert.h> <stdlib.h> <stdarg.h>
:END:

#+BEGIN_SRC C
char buffer[512] = "hello";
strcat (buffer, " ");
strcat (buffer, "world");
puts (buffer);
#+END_SRC

#+RESULTS:
: hello world

strcat should be avoided

#+BEGIN_SRC C
char *
concat (const char *str, ...)
{
  va_list ap;
  size_t allocated = 100;
  char *result = malloc (allocated);

  if (result != NULL)
    {
      char *newp;
      char *wp;
      const char *s;

      va_start (ap, str);

      wp = result;
      for (s = str; s != NULL; s = va_arg (ap, const char *))
        {
          size_t len = strlen (s);

          /* Resize the allocated memory if necessary.  */
          if (wp + len + 1 > result + allocated)
            {
              allocated = (allocated + len) * 2;
              newp = realloc (result, allocated);
              if (newp == NULL)
                {
                  free (result);
                  return NULL;
                }
              wp = newp + (wp - result);
              result = newp;
            }
          
          memcpy (wp, s, len);
          wp += len;
        }

      /* Terminate the result string.  */
      ,*wp++ = '\0';

      /* Resize memory to the optimal size.  */
      newp = realloc (result, wp - result);
      if (newp != NULL)
        result = newp;

      va_end (ap);
    }
  
  return result;
}

int
main ()
{
  char *result = concat ("Hello", ", ", "World", "!", NULL);
  puts (result);
  return 0;
}
#+END_SRC

#+RESULTS:
: Hello, World!

#+BEGIN_SRC C
char *s = "Hello, World!";
char buffer[100];
int size = 6;
assert (buffer == strncpy (buffer, s, size));
if (strlen (s) > size) 
  buffer[size] = '\0';
puts (buffer);
#+END_SRC

#+RESULTS:
: Hello,

** String/Array Comparison
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <assert.h> <stdlib.h>
:END:

#+BEGIN_SRC C
char *s1, *s2;
s1 = s2 = "hello";
printf ("%s %s %s\n", s1, strcmp (s1, s2) ? "!=" : "=", s2);

s2 = "HELLO";
printf ("%s %s %s\n", s1, strcmp (s1, s2) ? "!=" : "=", s2);
#+END_SRC

#+RESULTS:
: hello = hello
: hello != HELLO

memcmp compares two arrays byte-by-byte

#+BEGIN_SRC C
unsigned char ary1[] = { 'a', 'b', 'c' };
unsigned char ary2[] = { 'a', 'b', 'c' };
int size = sizeof ary1 / sizeof (unsigned char);
printf ("%d\n", memcmp (ary1, ary2, size));

ary2[size - 1] = 'C';
printf ("%d\n", memcmp (ary1, ary2, size));
printf ("%d\n", memcmp (ary2, ary1, size));
#+END_SRC

#+RESULTS:
: 0
: 32
: -32

~strcasecmp~ ignores case:

#+BEGIN_SRC C
printf ("%d\n", strcmp ("hello", "HELLO"));
printf ("%d\n", strcasecmp ("hello", "HELLO"));
#+END_SRC

#+RESULTS:
: 32
: 0

#+BEGIN_SRC C
printf ("%d", strncmp ("hello", "hello, world", strlen ("hello")));
#+END_SRC

#+RESULTS:
: 0

** Collation Functions
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <assert.h> <stdlib.h>
:END:

~strcoll~ is similar to ~strcmp~ but uses the locale.

#+BEGIN_SRC C
printf ("%d, %d", strcoll ("a", "b"), strcoll ("b", "a"));
#+END_SRC

#+RESULTS:
: -1, 1

Sort an array of strings:

#+BEGIN_SRC C :cmdline "d c b a"
int
compare_strings (const void *v1, const void *v2)
{
  char * const *p1 = v1;
  char * const *p2 = v2;
  return strcmp (*p1, *p2);
}

int
main (int argc, char **argv)
{
  for (int i = 1; i < argc; i++)
    printf ("%s ", argv[i]);
  puts ("");

  qsort (argv + 1, argc - 1, sizeof (char *), compare_strings);

  for (int i = 1; i < argc; i++)
    printf ("%s ", argv[i]);

  return 0;
}
#+END_SRC

#+RESULTS:
: d c b a 
: a b c d

** Search Functions
:PROPERTIES:
:header-args:C: :results output :includes <stdio.h> <string.h> <assert.h> <stdlib.h>
:END:

#+BEGIN_SRC C :cmdline "'hello world'"
int
main (int argc, char *argv[argc+1])
{
  char *string;
  char c;
  char *wp;
  char *result;
  int len;

  string = argv[1];
  printf ("The String is '%s'\n", string);

  c = 'o';
  wp = memchr (string, c, strlen (string));

  if (wp == NULL)
    {
      printf ("No match was found, '%s' doesn't contains '%c'\n", string, c);
      exit (0);
    }

  len = wp - string + 1;
  result = malloc (len + 1);

  if (result == NULL)
    {
      printf ("malloc failed\n");
      exit (0);
    }

  memcpy (result, string, len);
  result[len] = '\0';

  printf ("and the substring till '%c' is '%s'", c, result);
  return 0;
}
#+END_SRC

#+RESULTS:
: The String is 'hello world'
: and the substring till 'o' is 'hello'

#+BEGIN_SRC C
puts (memchr ("hello, world", 'o', 12));
puts (strchr ("hello, world", 'o'));
#+END_SRC

#+RESULTS:
: o, world
: o, world

strchr v.s. strlen

#+BEGIN_SRC C
{
  char buffer[10] = "hello";
  char *p  = buffer + strlen (buffer);
  ,*p = '!',  *(p+1) = '\0';
  puts (buffer);
}

{
  char buffer[10] = "hello";
  char *p  = strchr (buffer, '\0');
  ,*p = '!',  *(p+1) = '\0';
  puts (buffer);
}

#+END_SRC

#+RESULTS:
: hello!
: hello!
